{
    "IperEdge": [
        {
            "tags": [],
            "description": {
                "full": "check that nodeIds refers to existing nodes",
                "summary": "check that nodeIds refers to existing nodes",
                "body": ""
            },
            "ignore": false,
            "code": "if (_.isUndefined(node))\n      throw new Error()"
        },
        {
            "tags": [],
            "description": {
                "full": "if maxDegree is not defined there is no trouble ...",
                "summary": "if maxDegree is not defined there is no trouble ...",
                "body": ""
            },
            "ignore": false,
            "code": "if (_.isUndefined(node.maxDegree))\n      return"
        },
        {
            "tags": [],
            "description": {
                "full": "otherwise check that node degree is not going to exceed its maxDegree",
                "summary": "otherwise check that node degree is not going to exceed its maxDegree",
                "body": ""
            },
            "ignore": false,
            "code": "if (node.degree === node.maxDegree)\n      throw new Error()\n  })\n\n  IperElement.call(this, graph)\n\n  //\n  // ## Attributes\n  //\n\n  //\n  // ### nodeIds\n  //\n  // It is an array of node ids.\n  //\n\n  Object.defineProperty(this, 'nodeIds', {\n    enumerable: true,\n    value: nodeIds\n  })"
        },
        {
            "tags": [],
            "description": {
                "full": "add this edge to graph",
                "summary": "add this edge to graph",
                "body": ""
            },
            "ignore": false,
            "code": "graph.edges.push(this)\n}\n\ninherits(IperEdge, IperElement)"
        },
        {
            "tags": [],
            "description": {
                "full": "Removes the edge from its graph",
                "summary": "Removes the edge from its graph",
                "body": ""
            },
            "ignore": false,
            "code": "function remove () {\n  this.graph.removeEdge(this.id)\n}\n\nIperEdge.prototype.remove = remove\n\nmodule.exports = IperEdge",
            "ctx": {
                "type": "function",
                "name": "remove",
                "string": "remove()"
            }
        }
    ],
    "IperElement": [
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "graph",
                    "description": ""
                }
            ],
            "description": {
                "full": "Base class for *iper*.\n\nDo not use *IperElement* directly, it is used internally by *iper* as a base class.\n\nIf `this` refers to an *iper* class instance\n\n```\nIperElement.call(this, graph)\n```\n",
                "summary": "Base class for *iper*.",
                "body": "Do not use *IperElement* directly, it is used internally by *iper* as a base class.\n\nIf `this` refers to an *iper* class instance\n\n```\nIperElement.call(this, graph)\n```\n"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "function IperElement (graph) {\n\n  //\n  // ## Attributes\n  //\n\n  //\n  // ### graph\n  //\n  // References the graph containing the element.\n  //",
            "ctx": {
                "type": "function",
                "name": "IperElement",
                "string": "IperElement()"
            }
        },
        {
            "tags": [],
            "description": {
                "full": "check graph",
                "summary": "check graph",
                "body": ""
            },
            "ignore": false,
            "code": "if (_.isUndefined(graph))\n    throw new Error('graph is not defined')\n\n  Object.defineProperty(this, 'graph', {\n    enumerable: false,\n    value: graph,\n    writable: false\n  })\n\n  //\n  // ### id\n  //\n  // Every IperElement has a unique id.\n  //\n\n  Object.defineProperty(this, 'id', {\n    enumerable: true,\n    value: _.uniqueId(),\n    writable: false\n  })\n}\n\nmodule.exports = IperElement"
        }
    ],
    "IperGraph": [
        {
            "tags": [],
            "description": {
                "full": "TODO\n  //\n  // ### rank\n  //\n\n  Object.defineProperty(this, 'rank', {value: {}})",
                "summary": "TODO\n  //\n  // ### rank\n  //",
                "body": "  Object.defineProperty(this, 'rank', {value: {}})"
            },
            "ignore": false
        },
        {
            "tags": [],
            "description": {
                "full": "try to load data passed to constructor",
                "summary": "try to load data passed to constructor",
                "body": ""
            },
            "ignore": false,
            "code": "try {\n    this.load( {\n      edges: args.edges,\n      nodes: args.nodes\n    })\n  }\n  catch (err) { throw err }\n}\n\n//\n// ## Methods\n//\n\n//\n// ### check(data)\n//\n// **TODO**: vedi se riesco a referenziare la funzione load qui sotto nella documentazione\n// This method is used by load to check data is valid\n// ma pu√≤ essere usata anche esternamente come metodo statico\n// dovrebbe essere statico ma ereditabile\n//\n\n\n//\n// Given an object with the following format\n//\n// ```\n// {\n//   nodes: [\n//     {\n//       id: 1\n//     },\n//     {\n//       id: 2\n//     }\n//     ...\n//   ],\n//   edges: [\n//     {\n//       id: 3,\n//       nodeIds: [1, 2]\n//     }\n//     ...\n//   ]\n// }\n// ```\n//\n// performs the followings data checks\n//"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "data",
                    "description": ""
                }
            ],
            "description": {
                "full": "Performs dataa check\n",
                "summary": "Performs dataa check\n",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "function check(data) {\n  var edges    = data.edges    || []\n    , nodes    = data.nodes    || []\n\n  var nodeIds = _.pluck(nodes, 'id')\n\n  // * ids are unique",
            "ctx": {
                "type": "function",
                "name": "check",
                "string": "check()"
            }
        },
        {
            "tags": [],
            "description": {
                "full": "TODO Da fare anche su edges e subgraph",
                "summary": "TODO Da fare anche su edges e subgraph",
                "body": ""
            },
            "ignore": false,
            "code": "if (_.unique(nodeIds).length !== nodeIds.length)\n    throw new Error('duplicated node id')\n\n\n  // * edges refers to existing nodeIds\n  _.each(edges, function (edge) {\n    _.each(edge.nodeIds, function (nodeId) {\n      if (_.indexOf(nodeIds, nodeId) < 0)\n        throw new Error('invalid edge')\n    })\n  })\n\n  return true\n}\n\nIperGraph.prototype.check = check\n\n//\n// ### load(data) {#load}\n//\n\nfunction load(data) {\n  var self = this"
        },
        {
            "tags": [],
            "description": {
                "full": "check if data is valid",
                "summary": "check if data is valid",
                "body": ""
            },
            "ignore": false,
            "code": "try {\n    check(data)\n  }\n  catch (er) { throw er }\n\n  var edges = data.edges\n    , nodes = data.nodes"
        },
        {
            "tags": [],
            "description": {
                "full": "store a lookup of new <--> old ids",
                "summary": "store a lookup of new <--> old ids",
                "body": ""
            },
            "ignore": false,
            "code": "var brandNew = {}",
            "ctx": {
                "type": "declaration",
                "name": "brandNew",
                "value": "{}",
                "string": "brandNew"
            }
        },
        {
            "tags": [],
            "description": {
                "full": "create new nodes first",
                "summary": "create new nodes first",
                "body": ""
            },
            "ignore": false,
            "code": "_.each(nodes, function (node) {\n    var id = node.id\n      , opts = {}"
        },
        {
            "tags": [],
            "description": {
                "full": "remember association between old and new id",
                "summary": "remember association between old and new id",
                "body": ""
            },
            "ignore": false,
            "code": "brandNew[id] = self.createNode(id, opts)\n  })"
        },
        {
            "tags": [],
            "description": {
                "full": "create new edges",
                "summary": "create new edges",
                "body": ""
            },
            "ignore": false,
            "code": "_.each(edges, function (edge) {\n\n    var newNodeIds = []\n      , oldNodeIds = edge.nodeIds"
        },
        {
            "tags": [],
            "description": {
                "full": "loop over old node ids and get the corresponding new ids",
                "summary": "loop over old node ids and get the corresponding new ids",
                "body": ""
            },
            "ignore": false,
            "code": "_.each(oldNodeIds, function (id) {\n      newNodeIds.push(brandNew[id])\n    })"
        },
        {
            "tags": [],
            "description": {
                "full": "use new ids to create a new edge",
                "summary": "use new ids to create a new edge",
                "body": ""
            },
            "ignore": false,
            "code": "self.createEdge(newNodeIds)\n  })\n}\n\nIperGraph.prototype.load = load\n\n//\n// ### createEdge()\n//\n\nfunction createEdge(nodeIds) {\n  var edge = new IperEdge(this, nodeIds)\n  return edge.id\n}\n\nIperGraph.prototype.createEdge = createEdge\n\n//\n// ### createNode()\n//\n\nfunction createNode(opts) {\n  var node = new IperNode(this, opts)\n\n  // * returns node id\n  return node.id\n}\n\nIperGraph.prototype.createNode = createNode\n\n//\n// ### getEdge()\n//\n\nfunction getEdge(id) {\n  var edgeFound\n\n  _.each(this.edges, function (edge) {\n    if (id === edge.id)\n      edgeFound = edge\n  })\n\n  if (edgeFound)\n    return edgeFound\n  else\n    throw new Error('edge not found')\n}\n\nIperGraph.prototype.getEdge = getEdge\n\n//\n// ### getNode()\n//\n\nfunction getNode(id) {\n  var nodeFound\n\n  _.each(this.nodes, function (node) {\n    if (id === node.id)\n      nodeFound = node\n  })\n\n  if (nodeFound)\n    return nodeFound\n  else\n    throw new Error('node not found')\n}\n\nIperGraph.prototype.getNode = getNode\n\n//\n// ### removeEdge()\n//\n\nfunction removeEdge(id) {\n  var self = this;\n\n  _.each(self.edges, function (edge, index) {\n\n    if (id === edge.id)\n      self.edges.splice(index, 1)\n  })\n}\n\nIperGraph.prototype.removeEdge = removeEdge\n\n//\n// ### removeNode()\n//\n// Removes node by given id\n//\n//\n//```\n//graph.removeNode(nodeId)\n//```\n//\n\nfunction removeNode(id) {\n  var self = this\n\n  var edges = this.edges\n    , nodes = this.nodes"
        },
        {
            "tags": [],
            "description": {
                "full": "TODO fai try getNode per fare throw di node not found",
                "summary": "TODO fai try getNode per fare throw di node not found",
                "body": ""
            },
            "ignore": false
        },
        {
            "tags": [],
            "description": {
                "full": "loop over all edges",
                "summary": "loop over all edges",
                "body": ""
            },
            "ignore": false,
            "code": "_.each(edges, function (edge) {"
        },
        {
            "tags": [],
            "description": {
                "full": "loop over edge nodeIds",
                "summary": "loop over edge nodeIds",
                "body": ""
            },
            "ignore": false,
            "code": "_.each(edge.nodeIds, function (nodeId, index) {"
        },
        {
            "tags": [],
            "description": {
                "full": "drop nodeId from edges linked to removed node",
                "summary": "drop nodeId from edges linked to removed node",
                "body": ""
            },
            "ignore": false,
            "code": "if (id === nodeId)\n        edge.nodeIds.splice(index, 1)\n    })"
        },
        {
            "tags": [],
            "description": {
                "full": "remove orphan edges",
                "summary": "remove orphan edges",
                "body": ""
            },
            "ignore": false
        },
        {
            "tags": [],
            "description": {
                "full": "TODO in realta non sarebbe 2 ma il rank dell' edge",
                "summary": "TODO in realta non sarebbe 2 ma il rank dell' edge",
                "body": ""
            },
            "ignore": false,
            "code": "if (edge.nodeIds.length < 2)\n      edge.remove()\n  })\n\n  _.each(nodes, function (node, index) {\n    if (id === node.id)\n      self.nodes.splice(index, 1)\n  })\n}\n\nIperGraph.prototype.removeNode = removeNode\n\nmodule.exports = IperGraph"
        }
    ],
    "IperNode": [
        {
            "tags": [],
            "description": {
                "full": "Count occurrences of node id in edge.nodeIds\nfor every edge in the graph.",
                "summary": "Count occurrences of node id in edge.nodeIds\nfor every edge in the graph.",
                "body": ""
            },
            "ignore": false,
            "code": "_.each(graph.edges, function (edge) {\n      _.each(edge.nodeIds, function (nodeId) {\n        if (nodeId === self.id)\n          degree++\n      })\n    })\n\n    return degree\n  }\n\n  Object.defineProperty(this, 'degree', {get: getDegree})\n\n  function getMaxDegree () {\n    return opts.maxDegree\n  }\n\n  Object.defineProperty(this, 'maxDegree', {get: getMaxDegree})"
        },
        {
            "tags": [],
            "description": {
                "full": "add this node to graph",
                "summary": "add this node to graph",
                "body": ""
            },
            "ignore": false,
            "code": "graph.nodes.push(this)\n}\n\ninherits(IperNode, IperElement)"
        },
        {
            "tags": [
                {
                    "type": "return",
                    "types": [
                        "Array"
                    ],
                    "description": "adjacent node ids"
                }
            ],
            "description": {
                "full": "Compute adjacent nodes\n",
                "summary": "Compute adjacent nodes\n",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "function getAdjacentNodeIds() {\n  var id = this.id\n\n  var adjacentNodeIds = []",
            "ctx": {
                "type": "function",
                "name": "getAdjacentNodeIds",
                "string": "getAdjacentNodeIds()"
            }
        },
        {
            "tags": [],
            "description": {
                "full": "loop over all edges",
                "summary": "loop over all edges",
                "body": ""
            },
            "ignore": false,
            "code": "_.each(this.graph.edges, function (edge) {"
        },
        {
            "tags": [],
            "description": {
                "full": "if edge contains node",
                "summary": "if edge contains node",
                "body": ""
            },
            "ignore": false,
            "code": "if (_.contains(edge.nodeIds, id))"
        },
        {
            "tags": [],
            "description": {
                "full": "take all nodeIds except node self id",
                "summary": "take all nodeIds except node self id",
                "body": ""
            },
            "ignore": false,
            "code": "adjacentNodeIds.push(_.without(edge.nodeIds, id))\n  })"
        },
        {
            "tags": [],
            "description": {
                "full": "since _.without() return an array and nodeIds can be repeated,\nuse _.uniq() and _.flatten() to return a flat array with no repetition",
                "summary": "since _.without() return an array and nodeIds can be repeated,\nuse _.uniq() and _.flatten() to return a flat array with no repetition",
                "body": ""
            },
            "ignore": false,
            "code": "return _.uniq(_.flatten(adjacentNodeIds))\n}\n\nIperNode.prototype.getAdjacentNodeIds = getAdjacentNodeIds"
        },
        {
            "tags": [],
            "description": {
                "full": "TODO remove(), oppure toglilo ad IperEdge",
                "summary": "TODO remove(), oppure toglilo ad IperEdge",
                "body": ""
            },
            "ignore": false,
            "code": "module.exports = IperNode",
            "ctx": {
                "type": "property",
                "receiver": "module",
                "name": "exports",
                "value": "IperNode",
                "string": "module.exports"
            }
        }
    ]
}